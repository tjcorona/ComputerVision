#include "opencv2/ml/ml.hpp"
#include "opencv2/highgui/highgui.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include <iostream>
#include <sstream>

const int train_samples = 1;
const int classes = 10;
const int sizex = 20;
const int sizey = 30;
const int ImageSize = sizex * sizey;
char pathToImages[] = "Data";

void PreProcessImage(cv::Mat& inImage,cv::Mat& outImage,int sizex, int sizey);
void LearnFromImages(cv::Mat& trainData, cv::Mat& trainClasses);
void RunSelfTest(cv::KNearest& knn2);
void AnalyseImage(cv::KNearest knearest);
/** @function main */
int main(int argc, char** argv)
{

  cv::Mat trainData(classes * train_samples,ImageSize, CV_32FC1);
  cv::Mat trainClasses(classes * train_samples, 1, CV_32FC1);

  cv::namedWindow("single", CV_WINDOW_AUTOSIZE);
  cv::namedWindow("all",CV_WINDOW_AUTOSIZE);

  LearnFromImages(trainData, trainClasses);

  cv::KNearest knearest(trainData, trainClasses);

  RunSelfTest(knearest);

  AnalyseImage(knearest);

  return 0;

}

void PreProcessImage(cv::Mat& inImage,cv::Mat& outImage,int sizex, int sizey)
{
  cv::Mat grayImage,blurredImage,thresholdImage,contourImage,regionOfInterest;

  std::vector<std::vector<cv::Point> > contours;

  cvtColor(inImage,grayImage , cv::COLOR_BGR2GRAY);

  GaussianBlur(grayImage, blurredImage, cv::Size(5, 5), 2, 2);
  adaptiveThreshold(blurredImage, thresholdImage, 255, 1, 1, 11, 2);

  thresholdImage.copyTo(contourImage);

  findContours(contourImage, contours, cv::RETR_LIST, cv::CHAIN_APPROX_SIMPLE);

  int idx = 0;
  size_t area = 0;
  for (size_t i = 0; i < contours.size(); i++)
  {
    if (area < contours[i].size() )
    {
      idx = i;
      area = contours[i].size();
    }
  }

  cv::Rect rec = boundingRect(contours[idx]);

  regionOfInterest = thresholdImage(rec);

  resize(regionOfInterest,outImage, cv::Size(sizex, sizey));

}

void LearnFromImages(cv::Mat& trainData, cv::Mat& trainClasses)
{
  cv::Mat img;
  for (int i = 0; i < classes; i++)
  {
    std::stringstream s;
    s << pathToImages << "/" << i << ".png";
    img = cv::imread(s.str().c_str(), 1);
    if (!img.data)
    {
      std::cout << "File " << s.str() << " not found" << std::endl;
      exit(1);
    }
    cv::Mat outfile;
    PreProcessImage(img, outfile, sizex, sizey);
    for (int n = 0; n < ImageSize; n++)
    {
      trainData.at<float>(i * ImageSize + n) = outfile.at<float>(n);
    }
    trainClasses.at<float>(i) = i;
  }

}

void RunSelfTest(cv::KNearest& knn2)
{
  cv::Mat img;
  cv::Mat sample2(1, ImageSize, CV_32FC1);
  // SelfTest
  for (int z = 0; z < 10; z++)
  {
    int iSecret = rand() % 10;
    //cout << iSecret;
    {
      std::stringstream s; s << pathToImages << "/" << iSecret << ".png";
      img = cv::imread(s.str().c_str(), 1);
    }
    cv::Mat stagedImage;
    PreProcessImage(img, stagedImage, sizex, sizey);
    for (int n = 0; n < ImageSize; n++)
    {
      sample2.at<float>(n) = stagedImage.at<float>(n);
    }
    float detectedClass = knn2.find_nearest(sample2, 1);
    if (iSecret != (int) ((detectedClass)))
    {
      std::cout << "Misidentified " << iSecret << " as "
		<< (int) ((detectedClass)) << std::endl;
      exit(1);
    }
    std::cout << "Correct " << (int) ((detectedClass)) << std::endl;
    cv::imshow("single", img);
    cv::waitKey(0);
  }

}

void AnalyseImage(cv::KNearest knearest)
{

  cv::Mat sample2(1, ImageSize, CV_32FC1);

  cv::Mat image, gray, blur, thresh;

  std::vector < std::vector<cv::Point> > contours;
  image = cv::imread("Data/buchstaben.png", 1);

  cvtColor(image, gray, cv::COLOR_BGR2GRAY);
  GaussianBlur(gray, blur, cv::Size(5, 5), 2, 2);
  adaptiveThreshold(blur, thresh, 255, 1, 1, 11, 2);
  findContours(thresh, contours, cv::RETR_LIST, cv::CHAIN_APPROX_SIMPLE);

  for (size_t i = 0; i < contours.size(); i++)
  {
    std::vector < cv::Point > cnt = contours[i];
    if (contourArea(cnt) > 50)
    {
      cv::Rect rec = boundingRect(cnt);
      if (rec.height > 28)
      {
	cv::Mat roi = image(rec);
	cv::Mat stagedImage;
	PreProcessImage(roi, stagedImage, sizex, sizey);
	for (int n = 0; n < ImageSize; n++)
	{
	  sample2.at<float>(n) = stagedImage.at<float>(n);
	}
	float result = knearest.find_nearest(sample2, 1);
	rectangle(image, cv::Point(rec.x, rec.y),
		  cv::Point(rec.x + rec.width, rec.y + rec.height),
		  cv::Scalar(0, 0, 255), 2);

	cv::imshow("all", image);
	std::cout << result << std::endl;

	cv::imshow("single", stagedImage);
	cv::waitKey(0);
      }

    }

  }
}
